# H06: Construct Exploit (Failing Test)

## Context
Phase: **VERIFY** (3 of 3)
Scenario: Bug hunting, confirming suspected bugs

## Input Required
- Suspected bugs from H01-H05 (with malformation type)
- Source code
- Problem domain

## Prompt

```
TASK: Construct minimal test that triggers the suspected bug.

INPUT:
{suspected_bug}
{malformation_type}  -- ABSENT | MALFORMED_CONTRACT | MALFORMED_CODE | COMBINED
{eiffel_source_code}
{problem_domain}

═══════════════════════════════════════════════════════════════
EXPLOIT STRATEGY BY MALFORMATION TYPE
═══════════════════════════════════════════════════════════════

IF CONTRACT ABSENT:
  Strategy: Find input that SHOULD be rejected but isn't
  Exploit: Pass that input, observe incorrect behavior
  Verification: Show the damage that missing contract allowed

IF CONTRACT MALFORMED:
  Strategy: Find input that PASSES wrong contract but breaks feature
  Exploit: Satisfy the malformed contract, violate true intent
  Verification: Contract passes, but result is semantically wrong

IF CODE MALFORMED:
  Strategy: Find scenario where code violates domain rules
  Exploit: Execute feature, observe domain rule violation
  Verification: Show domain invariant broken

IF COMBINED:
  Strategy: Exploit weakest point in contract-code chain
  Exploit: Path of least resistance through malformations
  Verification: Show cascading failure

═══════════════════════════════════════════════════════════════
EXPLOIT CONSTRUCTION
═══════════════════════════════════════════════════════════════

1. STATE HYPOTHESIS
   "The {malformation_type} in {location} allows {bad_thing}"

2. DESIGN MINIMAL TRIGGER
   - Minimum state to reach vulnerable point
   - Minimum input to trigger malformation
   - Clear observation of failure

3. DEFINE SUCCESS CRITERIA
   For ABSENT: Exception or silent corruption occurs
   For MALFORMED_CONTRACT: Contract passes, domain violated
   For MALFORMED_CODE: Domain rule broken despite valid input

OUTPUT FORMAT:
BUG HYPOTHESIS: {one sentence}
MALFORMATION TYPE: [ABSENT | MALFORMED_CONTRACT | MALFORMED_CODE | COMBINED]

EXPLOIT:
```eiffel
test_exploit_{bug_name}
        -- Demonstrates: {hypothesis}
        -- Malformation: {type}
    local
        l_obj: {CLASS}
    do
        -- Setup: reach vulnerable state
        create l_obj.make
        {setup}

        -- Trigger: exploit the malformation
        l_obj.{feature} ({triggering_input})

        -- Verify: show the damage
        -- For ABSENT: this crashes or corrupts
        -- For MALFORMED_CONTRACT: contract passes but...
        assert ("contract_passed", {contract_check})  -- passes!
        assert ("but_domain_violated", {domain_check})  -- fails!
        -- For MALFORMED_CODE: domain rule broken
        assert ("domain_rule_broken", {rule_check})
    end
```

EXPECTED MANIFESTATION:
  Type: [CRASH | CONTRACT_VIOLATION | SILENT_CORRUPTION | DOMAIN_VIOLATION]
  If MALFORMED_CONTRACT: Contract {X} passes but {Y} is wrong
  If MALFORMED_CODE: Domain rule {Z} violated

DOMAIN IMPACT: {what this means in real-world terms}
```

## Success Criteria
- Malformation type explicitly exploited
- Minimal test case constructed
- Domain impact articulated
- Clear verification of the bug

## Next Step
→ H07-CONFIRM-ROOT-CAUSE.md (if confirmed)
→ Return to H03-H05 (if not triggered)
